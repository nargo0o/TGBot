#!/usr/bin/env python

"""This module contains the base class for handlers as used by the Dispatcher."""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Callable, Dict, Optional, TypeVar, Union, Generic

from telegram import Update
from telegram.ext.utils.promise import Promise
from telegram.utils.helpers import DefaultValue, DEFAULT_FALSE

if TYPE_CHECKING:
    from telegram.ext import CallbackContext, Dispatcher

RT = TypeVar('RT')
UT = TypeVar('UT')


class Handler(Generic[UT], ABC):
    """The base class for all update handlers. Create custom handlers by inheriting from it."""

    def __init__(
        self,
        callback: Callable[[UT, 'CallbackContext'], RT],
        pass_update_queue: bool = False,
        pass_job_queue: bool = False,
        pass_user_data: bool = False,
        pass_chat_data: bool = False,
        run_async: Union[bool, DefaultValue] = DEFAULT_FALSE,
    ):
        self.callback = callback
        self.pass_update_queue = pass_update_queue
        self.pass_job_queue = pass_job_queue
        self.pass_user_data = pass_user_data
        self.pass_chat_data = pass_chat_data
        self.run_async = run_async

    @abstractmethod
    def check_update(self, update: object) -> Optional[Union[bool, object]]:
        """
        This method is called to determine if an update should be handled by
        this handler instance. It should always be overridden.

        Note:
            Custom updates types can be handled by the dispatcher. Therefore, an implementation of
            this method should always check the type of :attr:`update`.

        Args:
            update (:obj:`str` | :class:`telegram.Update`): The update to be tested.

        Returns:
            Either :obj:`None` or :obj:`False` if the update should not be handled. Otherwise an
            object that will be passed to :meth:`handle_update` and
            :meth:`collect_additional_context` when the update gets handled.

        """

    def handle_update(
        self,
        update: UT,
        dispatcher: 'Dispatcher',
        check_result: object,
        context: 'CallbackContext' = None,
    ) -> Union[RT, Promise]:
        """
        This method is called if it was determined that an update should indeed
        be handled by this instance. Calls :attr:`callback` along with its respectful
        arguments. To work with the :class:`telegram.ext.ConversationHandler`, this method
        returns the value returned from :attr:`callback`.
        Note that it can be overridden if needed by the subclassing handler.

        Args:
            update (:obj:`str` | :class:`telegram.Update`): The update to be handled.
            dispatcher (:class:`telegram.ext.Dispatcher`): The calling dispatcher.
            check_result (:obj:`obj`): The result from :attr:`check_update`.
            context (:class:`telegram.ext.CallbackContext`, optional): The context as provided by
                the dispatcher.

        """
        run_async = self.run_async
        if self.run_async is DEFAULT_FALSE and dispatcher.bot.defaults:
            if dispatcher.bot.defaults.run_async:
                run_async = True

        if context:
            self.collect_additional_context(context, update, dispatcher, check_result)
            if run_async:
                return dispatcher.run_async(self.callback, update, context, update=update)
            return self.callback(update, context)

        optional_args = self.collect_optional_args(dispatcher, update, check_result)
        if run_async:
            return dispatcher.run_async(
                self.callback, dispatcher.bot, update, update=update, **optional_args
            )
        return self.callback(dispatcher.bot, update, **optional_args)  # type: ignore

    def collect_additional_context(
        self,
        context: 'CallbackContext',
        update: UT,
        dispatcher: 'Dispatcher',
        check_result: Any,
    ) -> None:
        """Prepares additional arguments for the context. Override if needed.

        Args:
            context (:class:`telegram.ext.CallbackContext`): The context object.
            update (:class:`telegram.Update`): The update to gather chat/user id from.
            dispatcher (:class:`telegram.ext.Dispatcher`): The calling dispatcher.
            check_result: The result (return value) from :attr:`check_update`.

        """

    def collect_optional_args(
        self,
        dispatcher: 'Dispatcher',
        update: UT = None,
        check_result: Any = None,  # pylint: disable=W0613
    ) -> Dict[str, object]:
        """
        Prepares the optional arguments. If the handler has additional optional args,
        it should subclass this method, but remember to call this super method.

        DEPRECATED: This method is being replaced by new context based callbacks. Please see
        https://git.io/fxJuV for more info.

        Args:
            dispatcher (:class:`telegram.ext.Dispatcher`): The dispatcher.
            update (:class:`telegram.Update`): The update to gather chat/user id from.
            check_result: The result from check_update

        """
        optional_args: Dict[str, object] = {}

        if self.pass_update_queue:
            optional_args['update_queue'] = dispatcher.update_queue
        if self.pass_job_queue:
            optional_args['job_queue'] = dispatcher.job_queue
        if self.pass_user_data and isinstance(update, Update):
            user = update.effective_user
            optional_args['user_data'] = dispatcher.user_data[
                user.id if user else None  # type: ignore[index]
            ]
        if self.pass_chat_data and isinstance(update, Update):
            chat = update.effective_chat
            optional_args['chat_data'] = dispatcher.chat_data[
                chat.id if chat else None  # type: ignore[index]
            ]

        return optional_args
